{
package expr

import (
	"bytes"
  "encoding/hex"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"os"
	"strings"
	"unicode"
	"unicode/utf8"
)
}

Start <- items_:Item+ _ EOF {
    items := items_.([]interface{})
    if len(items) == 1 {
        return items[0], nil
    }
    return Tuple(items), nil
}

Item <- _ it:(Array / Tuple / Hex / TypedNumeric / UntypedNumeric / Signature) {
    return it, nil
}

Array <- '[' items:Item* _ ']' {
    return Array(items.([]interface{})), nil
}

Tuple <- '(' items:Item+ _ ')' {
    return Tuple(items.([]interface{})), nil
}

UntypedNumeric <- number:Integer {
    return Numeric{
      Type: "i",
      Number: number.(string),
    }, nil
}

TypedNumeric <- t:Type ':' number:Integer {
    return Numeric{
      Type: t.(string),
      Number: number.(string),
    }, nil
}

Hex <- "0x" hexbytes:HexBytes {
    if len(hexbytes.([]byte)) % 2 == 1 {
        return nil, errors.New("Num hex digits must be even")
    }
    return Bytes(hexbytes.([]byte)), nil
}

HexBytes <- [0-9abcdefABCDEF]+ {
    bytez, err := hex.DecodeString(string(c.text))
    if err != nil {
        return nil, err
    }
    return bytez, nil
}

Type <- ("u64" / "i64") {
    return string(c.text), nil
}

Integer <- '-'? [0-9]+ {
    return string(c.text), nil
}

Label <- [0-9a-zA-Z]+ {
    return string(c.text), nil
}

Signature <- "<sig:" name:Label '>' {
    return Signature{
      Name: name.(string),
    }, nil
}

_ "whitespace" <- [ \n\t\r]*

EOF <- !.
